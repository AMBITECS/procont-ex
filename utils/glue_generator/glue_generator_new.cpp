#include <iostream>
#include <fstream>
#include <string>
#include <cstring>
#include <cstdlib>

#define MAX_LINE_INPUT 1024
#define MAX_LOCAL_BUFFER 100

using namespace std;

void generateHeader(ostream& glueVars) {
    glueVars << "//-----------------------------------------------------------------------------\n";
    glueVars << "// Автоматически сгенерированный файл связывания переменных\n";
    glueVars << "//-----------------------------------------------------------------------------\n\n";
    glueVars << "#include \"iec_std_lib.h\"\n";
    glueVars << "#include \"gateway.h\"\n\n";
    glueVars << "#define __LOCATED_VAR(type, name, ...) type __##name;\n";
    glueVars << "#include \"LOCATED_VARIABLES.h\"\n";
    glueVars << "#undef __LOCATED_VAR\n\n";
    glueVars << "#define __LOCATED_VAR(type, name, ...) type* name = &__##name;\n";
    glueVars << "#include \"LOCATED_VARIABLES.h\"\n";
    glueVars << "#undef __LOCATED_VAR\n\n";
    glueVars << "#define __BIND(reg, var) BindingManager::instance().bind(reg, (void*) var)\n\n";
    glueVars << "void glueVars() {\n";
}

void generateBottom(ostream& glueVars) {
    glueVars << "}\n";
}

void findPositions(char* varName, int* pos1, int* pos2) {
    int i = 4, j = 0;
    char tempBuffer[100];

    while (varName[i] != '_' && varName[i] != '\0') {
        tempBuffer[j] = varName[i];
        i++; j++;
        tempBuffer[j] = '\0';
    }
    *pos1 = atoi(tempBuffer);

    if (varName[i] == '\0') {
        *pos2 = 0;
        return;
    }

    j = 0; i++;
    while (varName[i] != '\0') {
        tempBuffer[j] = varName[i];
        i++; j++;
        tempBuffer[j] = '\0';
    }
    *pos2 = atoi(tempBuffer);
}

string getRegisterNotation(char* varName) {
    int pos1, pos2;
    findPositions(varName, &pos1, &pos2);

    char category = varName[2];
    char type = varName[3];

    string reg;
    reg += category;
    reg += type;

    if (type == 'X') {
        reg += to_string(pos1) + "." + to_string(pos2);
    } else {
        reg += to_string(pos1);
    }

    return reg;
}

void glueVar(ostream& glueVars, char* varName, char* varType) {
    string reg = getRegisterNotation(varName);
    string var = varName;

    glueVars << "\t__BIND(\"" << reg << "\", " << var << ");\n";
}

int parseIecVars(istream& locatedVars, char* varName, char* varType) {
    string line;
    char buffer[MAX_LINE_INPUT];

    if (getline(locatedVars, line)) {
        int i = 0, j = 0;
        strncpy(buffer, line.c_str(), MAX_LINE_INPUT);

        for (i = 0; i < MAX_LINE_INPUT && buffer[i] != '('; i++);
        i++;

        j = 0;
        while (i < MAX_LINE_INPUT && buffer[i] != ',') {
            if (j < MAX_LOCAL_BUFFER) {
                varType[j] = buffer[i];
                i++; j++;
                varType[j] = '\0';
            }
        }
        i++;

        j = 0;
        while (i < MAX_LINE_INPUT && buffer[i] != ',') {
            if (j < MAX_LOCAL_BUFFER) {
                varName[j] = buffer[i];
                i++; j++;
                varName[j] = '\0';
            }
        }

        return 1;
    }
    return 0;
}

void generateBody(istream& locatedVars, ostream& glueVars) {
    char iecVar_name[MAX_LOCAL_BUFFER];
    char iecVar_type[MAX_LOCAL_BUFFER];

    while (parseIecVars(locatedVars, iecVar_name, iecVar_type)) {
        glueVar(glueVars, iecVar_name, iecVar_type);
    }
}

/// This is our main function. We define it with a different name and then
/// call it from the main function so that we can mock it for the purpose
/// of testing.
int mainImpl(int argc, char *argv[])
{
    // Parse the command line arguments - if they exist. Show the help if there are too many arguments
    // or if the first argument is for help.
    bool show_help = argc >= 2 && (strcmp(argv[1], "-h") == 0 || strcmp(argv[1], "--help") == 0);
    if (show_help || (argc != 1 && argc != 3)) {
        cout << "Usage " << endl << endl;
        cout << "  glue_generator [options] <path-to-located-variables.h> <path-to-glue-vars.cpp>" << endl << endl;
        cout << "Reads the LOCATED_VARIABLES.h file generated by the MATIEC compiler and produces" << endl;
        cout << "glueVars.cpp for the OpenPLC runtime. If not specified, paths are relative to" << endl;
        cout << "the current directory." << endl << endl;
        cout << "Options" << endl;
        cout << "  --help,-h   = Print usage information and exit." << endl;
        return 0;
    }

    // If we have 3 arguments, then the user provided input and output paths
    string input_file_name("LOCATED_VARIABLES.h");
    string output_file_name("glueVars.cpp");
    if (argc == 3) {
        input_file_name = argv[1];
        output_file_name = argv[2];
    }

    // Try to open the files for reading and writing.
    ifstream locatedVars(input_file_name, ios::in);
    if (!locatedVars.is_open()) {
        cout << "Error opening located variables file at " << input_file_name << endl;
        return 1;
    }
    ofstream glueVars(output_file_name, ios::trunc);
    if (!glueVars.is_open()) {
        cout << "Error opening glue variables file at " << output_file_name << endl;
        return 2;
    }

    generateHeader(glueVars);
    generateBody(locatedVars, glueVars);
    generateBottom(glueVars);

    return 0;
}

// For testing, we need to allow omitting the main function defined here.
#ifndef OPLCGLUE_OMIT_MAIN
int main(int argc, char *argv[]) {
    return mainImpl(argc, argv);
}
#endif // OPLCGLUE_OMIT_MAIN


//int main(int argc, char* argv[]) {
//    if (argc != 3) {
//        cerr << "Usage: " << argv[0] << " <input_file> <output_file>" << endl;
//        return 1;
//    }
//
//    ifstream locatedVars(argv[1]);
//    if (!locatedVars.is_open()) {
//        cerr << "Error opening input file: " << argv[1] << endl;
//        return 1;
//    }
//
//    ofstream glueVars(argv[2]);
//    if (!glueVars.is_open()) {
//        cerr << "Error opening output file: " << argv[2] << endl;
//        return 1;
//    }
//
//    generateHeader(glueVars);
//    generateBody(locatedVars, glueVars);
//    generateBottom(glueVars);
//
//    return 0;
//}
